"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StdioDriver = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _enums = require("../enums");

var _lodash = require("lodash");

var _child_process = require("child_process");

var _readline = require("readline");

var readline = _interopRequireWildcard(_readline);

var _rx = require("rx");

var _runtime = require("../helpers/runtime");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var env = (0, _lodash.defaults)({ ATOM_SHELL_INTERNAL_RUN_AS_NODE: "1" }, process.env);

var StdioDriver = function () {
    function StdioDriver(_ref) {
        var _this = this;

        var projectPath = _ref.projectPath;
        var serverPath = _ref.serverPath;
        var findProject = _ref.findProject;
        var logger = _ref.logger;
        var timeout = _ref.timeout;
        var additionalArguments = _ref.additionalArguments;
        var runtime = _ref.runtime;
        var plugins = _ref.plugins;
        var version = _ref.version;

        _classCallCheck(this, StdioDriver);

        this._outstandingRequests = new Map();
        this._disposable = new _rx.CompositeDisposable();
        this._currentState = _enums.DriverState.Disconnected;
        this._commandStream = new _rx.Subject();
        this._eventStream = new _rx.Subject();
        this._connectionStream = new _rx.Subject();
        this._projectPath = projectPath;
        this._findProject = findProject || false;
        this._connectionStream.subscribe(function (state) {
            return _this.currentState = state;
        });
        this._logger = logger || console;
        this._serverPath = serverPath;
        this._timeout = (timeout || 60) * 1000;
        this._runtime = runtime || _enums.Runtime.ClrOrMono;
        this._additionalArguments = additionalArguments;
        this._plugins = plugins;
        this._version = version;
        this._runtimeContext = this._getRuntimeContext();
        this._disposable.add(_rx.Disposable.create(function () {
            if (_this._process) {
                _this._process.removeAllListeners();
            }
        }));
        this._disposable.add(_rx.Disposable.create(function () {
            var iterator = _this._outstandingRequests.entries();
            var iteratee = iterator.next();
            while (!iteratee.done) {
                var _iteratee$value = _slicedToArray(iteratee.value, 2);

                var key = _iteratee$value[0];
                var disposable = _iteratee$value[1];

                _this._outstandingRequests.delete(key);
                disposable.dispose();
                iteratee = iterator.next();
            }
            _this._outstandingRequests.clear();
        }));
    }

    _createClass(StdioDriver, [{
        key: "_getRuntimeContext",
        value: function _getRuntimeContext() {
            return new _runtime.RuntimeContext({
                runtime: this.runtime,
                platform: process.platform,
                arch: process.arch,
                version: this._version || undefined
            }, this._logger);
        }
    }, {
        key: "dispose",
        value: function dispose() {
            if (this._disposable.isDisposed) return;
            this.disconnect();
            this._disposable.dispose();
        }
    }, {
        key: "connect",
        value: function connect() {
            var _this2 = this;

            if (this._disposable.isDisposed) throw new Error("Driver is disposed");
            this._ensureRuntimeExists().subscribeOnCompleted(function () {
                return _this2._connect();
            });
            /*
            Enable once we can push a new build again
            this._disposable.add(this._ensureBootstrapExists()
                .subscribe((path) => this._serverPath = path, null, () => this._connect()));
            */
        }
    }, {
        key: "_connect",
        value: function _connect() {
            var _this3 = this;

            this._seq = 1;
            this._outstandingRequests.clear();
            this._connectionStream.onNext(_enums.DriverState.Connecting);
            var path = this.serverPath;
            this._logger.log("Connecting to child @ " + process.execPath);
            this._logger.log("Path to server: " + path);
            this._logger.log("Selected project: " + this._projectPath);
            env.PATH = this._PATH || env.PATH;
            var serverArguments = ["--stdio", "-s", this._projectPath, "--hostPID", process.pid].concat(this._additionalArguments || []);
            if ((0, _lodash.startsWith)(path, "mono ")) {
                serverArguments.unshift(path.substr(5));
                path = "mono";
            }
            this._logger.log("Arguments: " + serverArguments);
            this._process = (0, _child_process.spawn)(path, serverArguments, { env: env });
            if (!this._process.pid) {
                this.serverErr("failed to connect to connect to server");
                return;
            }
            this._process.stderr.on("data", function (data) {
                return _this3._logger.error(data.toString());
            });
            this._process.stderr.on("data", function (data) {
                return _this3.serverErr(data);
            });
            var rl = readline.createInterface({
                input: this._process.stdout,
                output: undefined
            });
            rl.on("line", function (data) {
                return _this3.handleData(data);
            });
            this.id = this._process.pid.toString();
            this._process.on("error", function (data) {
                return _this3.serverErr(data);
            });
            this._process.on("close", function () {
                return _this3.disconnect();
            });
            this._process.on("exit", function () {
                return _this3.disconnect();
            });
            this._process.on("disconnect", function () {
                return _this3.disconnect();
            });
        }
    }, {
        key: "_ensureRuntimeExists",
        value: function _ensureRuntimeExists() {
            var _this4 = this;

            this._connectionStream.onNext(_enums.DriverState.Downloading);
            return _rx.Observable.fromPromise((0, _runtime.isSupportedRuntime)(this._runtimeContext).do(function (ctx) {
                _this4._runtime = ctx.runtime;
                _this4._PATH = ctx.path;
                _this4._runtimeContext = _this4._getRuntimeContext();
            }).toPromise().then(function (runtime) {
                return _this4._runtimeContext.downloadRuntimeIfMissing().tapOnCompleted(function () {
                    _this4._connectionStream.onNext(_enums.DriverState.Downloaded);
                }).toPromise();
            }));
        }
        /*private _ensureBootstrapExists() {
            return this._ensureRuntimeExists()
                .flatMap(() => getPluginPath(this._projectPath, this._runtime, process, this._plugins, this._logger));
        }*/

    }, {
        key: "updatePlugins",
        value: function updatePlugins(plugins) {
            this._plugins = plugins;
            this.disconnect();
            this.connect();
        }
    }, {
        key: "serverErr",
        value: function serverErr(data) {
            var friendlyMessage = this.parseError(data);
            this._connectionStream.onNext(_enums.DriverState.Error);
            this._process = null;
            this._eventStream.onNext({
                Type: "error",
                Event: "error",
                Seq: -1,
                Body: {
                    Message: friendlyMessage
                }
            });
        }
    }, {
        key: "parseError",
        value: function parseError(data) {
            var message = data.toString();
            if (data.code === "ENOENT" && data.path === "mono") {
                message = "mono could not be found, please ensure it is installed and in your path";
            }
            return message;
        }
    }, {
        key: "disconnect",
        value: function disconnect() {
            if (this._process != null && this._process.pid) {
                this._process.kill("SIGTERM");
            }
            this._process = null;
            this._connectionStream.onNext(_enums.DriverState.Disconnected);
        }
    }, {
        key: "request",
        value: function request(command, _request) {
            if (!this._process) {
                return _rx.Observable.throw(new Error("Server is not connected, erroring out"));
            }
            var sequence = this._seq++;
            var packet = {
                Command: command,
                Seq: sequence,
                Arguments: _request
            };
            var subject = new _rx.AsyncSubject();
            this._outstandingRequests.set(sequence, subject);
            this._process.stdin.write(JSON.stringify(packet) + "\n", "utf8");
            return subject.timeout(this._timeout, _rx.Observable.throw("Request timed out"));
        }
    }, {
        key: "handleData",
        value: function handleData(data) {
            var packet = void 0;
            try {
                packet = JSON.parse(data.trim());
            } catch (_error) {
                this.handleNonPacket(data);
            }
            if (packet) {
                this.handlePacket(packet);
            }
        }
    }, {
        key: "handlePacket",
        value: function handlePacket(packet) {
            if (packet.Type === "response") {
                this.handlePacketResponse(packet);
            } else if (packet.Type === "event") {
                this.handlePacketEvent(packet);
            }
        }
    }, {
        key: "handlePacketResponse",
        value: function handlePacketResponse(response) {
            if (this._outstandingRequests.has(response.Request_seq)) {
                var observer = this._outstandingRequests.get(response.Request_seq);
                this._outstandingRequests.delete(response.Request_seq);
                if (observer.isDisposed) return;
                if (response.Success) {
                    observer.onNext(response.Body);
                    observer.onCompleted();
                } else {
                    observer.onError(response.Message);
                }
            } else {
                if (response.Success) {
                    this._commandStream.onNext(response);
                } else {}
            }
        }
    }, {
        key: "handlePacketEvent",
        value: function handlePacketEvent(event) {
            this._eventStream.onNext(event);
            if (event.Event === "started") {
                this._connectionStream.onNext(_enums.DriverState.Connected);
            }
        }
    }, {
        key: "handleNonPacket",
        value: function handleNonPacket(data) {
            var s = data.toString();
            this._eventStream.onNext({
                Type: "unknown",
                Event: "unknown",
                Seq: -1,
                Body: {
                    Message: s
                }
            });
            var ref = s.match(/Detected an OmniSharp instance already running on port/);
            if ((ref != null ? ref.length : 0) > 0) {
                this.disconnect();
            }
        }
    }, {
        key: "currentState",
        get: function get() {
            return this._currentState;
        },
        set: function set(value) {
            this._currentState = value;
        }
    }, {
        key: "serverPath",
        get: function get() {
            if (this._serverPath) {
                return this._serverPath;
            }
            return this._runtimeContext.location;
        }
    }, {
        key: "projectPath",
        get: function get() {
            return this._projectPath;
        }
    }, {
        key: "runtime",
        get: function get() {
            return this._runtime;
        }
    }, {
        key: "commands",
        get: function get() {
            return this._commandStream;
        }
    }, {
        key: "events",
        get: function get() {
            return this._eventStream;
        }
    }, {
        key: "state",
        get: function get() {
            return this._connectionStream;
        }
    }, {
        key: "outstandingRequests",
        get: function get() {
            return this._outstandingRequests.size;
        }
    }]);

    return StdioDriver;
}();

exports.StdioDriver = StdioDriver;