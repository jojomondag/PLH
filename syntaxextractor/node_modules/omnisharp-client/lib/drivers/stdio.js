"use strict";

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StdioDriver = undefined;

var _lodash = require("lodash");

var _enums = require("../enums");

var _child_process = require("child_process");

var _readline = require("readline");

var readline = _interopRequireWildcard(_readline);

var _rx = require("rx");

var _path = require("path");

var _omnisharpPath = require("../omnisharp-path");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var win32 = false;
var env = undefined;
// Setup the new process env.
if (process.platform === "win32") {
    win32 = true;
    // ALL I have to say is WTF.
    env = { ATOM_SHELL_INTERNAL_RUN_AS_NODE: "1" };
} else {
    env = (0, _lodash.defaults)({ ATOM_SHELL_INTERNAL_RUN_AS_NODE: "1" }, process.env);
}

var StdioDriver = (function () {
    function StdioDriver(_ref) {
        var _this = this;

        var projectPath = _ref.projectPath;
        var serverPath = _ref.serverPath;
        var findProject = _ref.findProject;
        var logger = _ref.logger;
        var timeout = _ref.timeout;
        var additionalArguments = _ref.additionalArguments;

        _classCallCheck(this, StdioDriver);

        this._outstandingRequests = new Map();
        this._currentState = _enums.DriverState.Disconnected;
        this._disposable = new _rx.CompositeDisposable();
        this._commandStream = new _rx.Subject();
        this._eventStream = new _rx.Subject();
        this._connectionStream = new _rx.Subject();
        this._projectPath = projectPath;
        this._findProject = findProject || false;
        this._serverPath = serverPath || _omnisharpPath.omnisharpLocation;
        this._connectionStream.subscribe(function (state) {
            return _this.currentState = state;
        });
        this._logger = logger || console;
        this._timeout = (timeout || 60) * 1000;
        this._additionalArguments = additionalArguments;
        this._disposable.add(this._commandStream);
        this._disposable.add(this._eventStream);
        this._disposable.add(this._connectionStream);
        this._disposable.add(_rx.Disposable.create(function () {
            if (_this._process) {
                _this._process.removeAllListeners();
            }
        }));
        this._disposable.add(_rx.Disposable.create(function () {
            var iterator = _this._outstandingRequests.entries();
            var iteratee = iterator.next();
            while (!iteratee.done) {
                var _iteratee$value = _slicedToArray(iteratee.value, 2);

                var key = _iteratee$value[0];
                var disposable = _iteratee$value[1];

                _this._outstandingRequests.delete(key);
                disposable.dispose();
                iteratee = iterator.next();
            }
        }));
    }

    _createClass(StdioDriver, [{
        key: "dispose",
        value: function dispose() {
            if (this._disposable.isDisposed) return;
            this.disconnect();
            this._disposable.dispose();
        }
    }, {
        key: "connect",
        value: function connect() {
            var _this2 = this;

            this._seq = 1;
            this._outstandingRequests.clear();
            if (!this._connectionStream.isDisposed) {
                this._connectionStream.onNext(_enums.DriverState.Connecting);
            }
            this._logger.log("Connecting to child @ " + process.execPath);
            this._logger.log("Path to server: " + this._serverPath);
            this._logger.log("Selected project: " + this._projectPath);
            if (win32) {
                // Spawn a special windows only node client... so that we can shutdown nicely.
                var serverArguments = [(0, _path.join)(__dirname, "../stdio/child.js"), "--serverPath", this._serverPath, "--projectPath", this._projectPath].concat(this._additionalArguments || []);
                this._logger.log("Arguments: " + serverArguments);
                this._process = (0, _child_process.spawn)(process.execPath, serverArguments, { env: env });
            } else {
                var serverArguments = ["--stdio", "-s", this._projectPath, "--hostPID", process.pid].concat(this._additionalArguments || []);
                this._logger.log("Arguments: " + serverArguments);
                this._process = (0, _child_process.spawn)(this._serverPath, serverArguments, { env: env });
            }
            if (!this._process.pid) {
                this.serverErr("failed to connect to connect to server");
                return;
            }
            this._process.stderr.on("data", function (data) {
                return _this2._logger.error(data.toString());
            });
            this._process.stderr.on("data", function (data) {
                return _this2.serverErr(data);
            });
            var rl = readline.createInterface({
                input: this._process.stdout,
                output: undefined
            });
            rl.on("line", function (data) {
                return _this2.handleData(data);
            });
            //rl.on("line", (data) => enqueue(() => this.handleData(data)));
            this.id = this._process.pid.toString();
            this._process.on("error", function (data) {
                return _this2.serverErr(data);
            });
            this._process.on("close", function () {
                return _this2.disconnect();
            });
            this._process.on("exit", function () {
                return _this2.disconnect();
            });
            this._process.on("disconnect", function () {
                return _this2.disconnect();
            });
        }
    }, {
        key: "serverErr",
        value: function serverErr(data) {
            var friendlyMessage = this.parseError(data);
            if (!this._connectionStream.isDisposed) {
                this._connectionStream.onNext(_enums.DriverState.Error);
            }
            this._process = null;
            if (!this._eventStream.isDisposed) {
                this._eventStream.onNext({
                    Type: "error",
                    Event: "error",
                    Seq: -1,
                    Body: {
                        Message: friendlyMessage
                    }
                });
            }
        }
    }, {
        key: "parseError",
        value: function parseError(data) {
            var message = data.toString();
            if (data.code === "ENOENT" && data.path === "mono") {
                message = "mono could not be found, please ensure it is installed and in your path";
            }
            return message;
        }
    }, {
        key: "disconnect",
        value: function disconnect() {
            if (this._process != null && this._process.pid) {
                this._process.kill("SIGTERM");
            }
            this._process = null;
            if (!this._connectionStream.isDisposed) this._connectionStream.onNext(_enums.DriverState.Disconnected);
        }
    }, {
        key: "request",
        value: function request(command, _request) {
            if (!this._process) {
                return _rx.Observable.throw(new Error("Server is not connected, erroring out"));
            }
            var sequence = this._seq++;
            var packet = {
                Command: command,
                Seq: sequence,
                Arguments: _request
            };
            var subject = new _rx.AsyncSubject();
            this._outstandingRequests.set(sequence, subject);
            this._process.stdin.write(JSON.stringify(packet) + "\n", "utf8");
            return subject.timeout(this._timeout, _rx.Observable.throw("Request timed out"));
        }
    }, {
        key: "handleData",
        value: function handleData(data) {
            var packet = undefined;
            try {
                packet = JSON.parse(data.trim());
            } catch (_error) {
                this.handleNonPacket(data);
            }
            if (packet) {
                this.handlePacket(packet);
            }
        }
    }, {
        key: "handlePacket",
        value: function handlePacket(packet) {
            if (packet.Type === "response") {
                this.handlePacketResponse(packet);
            } else if (packet.Type === "event") {
                this.handlePacketEvent(packet);
            }
        }
    }, {
        key: "handlePacketResponse",
        value: function handlePacketResponse(response) {
            if (this._outstandingRequests.has(response.Request_seq)) {
                var observer = this._outstandingRequests.get(response.Request_seq);
                this._outstandingRequests.delete(response.Request_seq);
                if (observer.isDisposed) return;
                if (response.Success) {
                    observer.onNext(response.Body);
                    observer.onCompleted();
                } else {
                    observer.onError(response.Message);
                }
            } else {
                if (!this._commandStream.isDisposed && response.Success) {
                    this._commandStream.onNext(response);
                } else {}
            }
        }
    }, {
        key: "handlePacketEvent",
        value: function handlePacketEvent(event) {
            if (!this._eventStream.isDisposed) {
                this._eventStream.onNext(event);
            }
            if (!this._connectionStream.isDisposed && event.Event === "started") {
                this._connectionStream.onNext(_enums.DriverState.Connected);
            }
        }
    }, {
        key: "handleNonPacket",
        value: function handleNonPacket(data) {
            var s = data.toString();
            if (!this._eventStream.isDisposed) {
                this._eventStream.onNext({
                    Type: "unknown",
                    Event: "unknown",
                    Seq: -1,
                    Body: {
                        Message: s
                    }
                });
            }
            var ref = s.match(/Detected an OmniSharp instance already running on port/);
            if ((ref != null ? ref.length : 0) > 0) {
                this.disconnect();
            }
        }
    }, {
        key: "currentState",
        get: function get() {
            return this._currentState;
        },
        set: function set(value) {
            // Prevent the client from leaving the error state
            // Error means bad things, like mono is working right
            if (this._currentState !== _enums.DriverState.Error) {
                this._currentState = value;
            }
        }
    }, {
        key: "serverPath",
        get: function get() {
            return this._serverPath;
        }
    }, {
        key: "projectPath",
        get: function get() {
            return this._projectPath;
        }
    }, {
        key: "commands",
        get: function get() {
            return this._commandStream;
        }
    }, {
        key: "events",
        get: function get() {
            return this._eventStream;
        }
    }, {
        key: "state",
        get: function get() {
            return this._connectionStream;
        }
    }, {
        key: "outstandingRequests",
        get: function get() {
            return this._outstandingRequests.size;
        }
    }]);

    return StdioDriver;
})();

exports.StdioDriver = StdioDriver;