"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getPluginPath = getPluginPath;

var _rx = require("rx");

var _fs = require("fs");

var fs = _interopRequireWildcard(_fs);

var _child_process = require("child_process");

var _path = require("path");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var bootstrappedPlugins = new Map();
var exists = _rx.Observable.fromCallback(fs.exists),
    readFile = _rx.Observable.fromNodeCallback(fs.readFile);
var md5 = require("md5");
function getPluginPath(solutionLocation, ctx, requestedPlugins, logger) {
    var plugins = [];
    var hashStrings = [];
    var hash = void 0;
    requestedPlugins.forEach(function (plugin) {
        plugins.push(plugin);
    });
    return _rx.Observable.create(function (observer) {
        logger.log("Bootstrapping " + solutionLocation);
        // Include the plugins defined in omnisharp.json, they could have changed.
        exists((0, _path.join)(solutionLocation, "omnisharp.json")).where(function (x) {
            return !!x;
        }).flatMap(function (x) {
            return readFile((0, _path.join)(solutionLocation, "omnisharp.json"));
        }).map(function (x) {
            return JSON.parse(x.toString());
        }).tapOnNext(function (obj) {
            if (obj.plugins) {
                hashStrings.push(obj.plugins);
            }
        }).subscribeOnCompleted(function () {
            hash = md5(JSON.stringify(plugins.concat(hashStrings)));
            if (bootstrappedPlugins.has(hash)) {
                observer.onNext(bootstrappedPlugins.get(hash));
                observer.onCompleted();
                return;
            }
            var command = [ctx.location, "-s", solutionLocation].concat(plugins.map(function (x) {
                if (x.location) {
                    return "--plugins " + x.location;
                } else if (x.version) {
                    return "--plugin-name " + x.name + "@" + x.version;
                } else {
                    return "--plugin-name " + x.name;
                }
            })).join(" ");
            (0, _child_process.exec)(command, function (error, stdout) {
                if (error) {
                    observer.onError(error);
                    return;
                }
                var location = stdout.toString().trim();
                if (location) {
                    // restore(location, ctx, logger).subscribe(observer);
                    return;
                }
                observer.onNext(ctx.location);
                observer.onCompleted();
            });
        });
    }).map(function (path) {
        return path && path || ctx.location;
    }).do(function (result) {
        if (!bootstrappedPlugins.has(hash)) bootstrappedPlugins.set(hash, result);
        logger.log("Finished bootstrapping " + solutionLocation);
    });
}