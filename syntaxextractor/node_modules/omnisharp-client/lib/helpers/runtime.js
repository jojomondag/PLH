"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isSupportedRuntime = exports.RuntimeContext = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.findRuntimeById = findRuntimeById;

var _rx = require("rx");

var _path = require("path");

var _fs = require("fs");

var fs = _interopRequireWildcard(_fs);

var _enums = require("../enums");

var _lodash = require("lodash");

var _decompress = require("./decompress");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var request = require("request");
var defaultServerVersion = require((0, _path.resolve)(__dirname, "../../package.json"))["omnisharp-roslyn"];
var exists = _rx.Observable.fromCallback(fs.exists);
var readFile = _rx.Observable.fromNodeCallback(fs.readFile);
var defaultDest = (0, _path.resolve)(__dirname, "../../");
// Handle the case of homebrew mono
var PATH = (0, _lodash.find)(process.env, function (v, key) {
    return (0, _lodash.toLower)(key) === "path";
}).split(_path.delimiter).concat(["/usr/local/bin", "/Library/Frameworks/Mono.framework/Commands"]);
;

var RuntimeContext = exports.RuntimeContext = function () {
    function RuntimeContext(runtimeContext, _logger) {
        _classCallCheck(this, RuntimeContext);

        this._logger = _logger;
        if (!_logger) {
            this._logger = console;
        }
        var self = this;
        (0, _lodash.assignWith)(self, runtimeContext || {}, function (obj, src, key) {
            self["_" + key] = obj || src;
        });
        if ((0, _lodash.isNull)(this._runtime) || (0, _lodash.isUndefined)(this._runtime)) {
            this._runtime = _enums.Runtime.ClrOrMono;
        }
        if ((0, _lodash.isNull)(this._platform) || (0, _lodash.isUndefined)(this._platform)) {
            this._platform = process.platform;
        }
        if ((0, _lodash.isNull)(this._arch) || (0, _lodash.isUndefined)(this._arch)) {
            this._arch = process.arch;
        }
        if ((0, _lodash.isNull)(this._version) || (0, _lodash.isUndefined)(this._version)) {
            this._version = defaultServerVersion;
        }
        this._arch = this._arch === "x86" ? "x86" : "x64";
        this._os = this._getOsName();
        this._key = this._getIdKey();
        this._id = "omnisharp-" + this._key;
        if ((0, _lodash.isNull)(this._location) || (0, _lodash.isUndefined)(this._location)) {
            this._location = this._getRuntimeLocation();
        }
        if ((0, _lodash.isNull)(this._destination) || (0, _lodash.isUndefined)(this._destination)) {
            this._destination = (0, _path.resolve)(defaultDest, this._id);
        }
        Object.freeze(this);
    }

    _createClass(RuntimeContext, [{
        key: "_getIdKey",
        value: function _getIdKey() {
            if (this._platform !== "win32" && this._runtime === _enums.Runtime.ClrOrMono) {
                return "linux-mono";
            }
            var runtimeName = "dnxcore50";
            if (this._runtime === _enums.Runtime.ClrOrMono) {
                if (this._platform === "win32") {
                    runtimeName = "dnx451";
                } else {
                    runtimeName = "mono";
                }
            }
            return this._os + "-" + this._arch + "-" + runtimeName;
        }
    }, {
        key: "_getOsName",
        value: function _getOsName() {
            if (this._platform === "win32") return "win";
            if (this._platform === "darwin") return "osx";
            return this._platform;
        }
        /* tslint:disable:no-string-literal */

    }, {
        key: "_getRuntimeLocation",
        value: function _getRuntimeLocation() {
            /*if (ctx.bootstrap) {
                const bootstrap = process.platform === "win32" ? "OmniSharp.exe" : "omnisharp.bootstrap";
                return <string>process.env["OMNISHARP_BOOTSTRAP"] || resolve(__dirname, "../../", getRuntimeId(ctx), bootstrap);
            }*/
            var path = process.env["OMNISHARP"];
            if (!path) {
                var omnisharp = process.platform === "win32" || this._runtime === _enums.Runtime.ClrOrMono ? "OmniSharp.exe" : "OmniSharp";
                path = (0, _path.resolve)(__dirname, "../../", this._id, omnisharp);
            }
            if (process.platform !== "win32" && this._runtime === _enums.Runtime.ClrOrMono) {
                return "mono " + path;
            }
            return path;
        }
        /* tslint:enable:no-string-literal */

    }, {
        key: "_checkCurrentVersion",
        value: function _checkCurrentVersion() {
            var _this = this;

            var filename = (0, _path.join)(this._destination, ".version");
            return exists(filename).flatMap(function (ex) {
                return _rx.Observable.if(function () {
                    return ex;
                }, _rx.Observable.defer(function () {
                    return readFile(filename).map(function (content) {
                        return content.toString().trim() === _this._version;
                    });
                }), _rx.Observable.just(false));
            });
        }
    }, {
        key: "_ensureCurrentVersion",
        value: function _ensureCurrentVersion() {
            var _this2 = this;

            var dest = this._destination;
            return this._checkCurrentVersion().flatMap(function (isCurrent) {
                return _rx.Observable.if(function () {
                    return !isCurrent;
                }, _rx.Observable.defer(function () {
                    return _rx.Observable.create(function (observer) {
                        dest = dest || defaultDest;
                        require("rimraf")(dest, function (err) {
                            if (err) {
                                observer.onError(err);
                                return;
                            }
                            (0, _lodash.delay)(function () {
                                return fs.mkdir(dest, function (er) {
                                    //if (er) { observer.onError(er); return; }
                                    fs.writeFile((0, _path.join)(dest, ".version"), _this2._version, function (e) {
                                        if (e) {
                                            observer.onError(e);
                                            return;
                                        }
                                        observer.onNext(isCurrent);
                                        observer.onCompleted();
                                    });
                                });
                            }, 500);
                        });
                    });
                }), _rx.Observable.just(isCurrent));
            });
        }
    }, {
        key: "findRuntime",
        value: function findRuntime() {
            var location = arguments.length <= 0 || arguments[0] === undefined ? (0, _path.resolve)(defaultDest) : arguments[0];

            return findRuntimeById(this._id, location);
        }
    }, {
        key: "downloadRuntime",
        value: function downloadRuntime() {
            var _this3 = this;

            return _rx.Observable.defer(function () {
                return _rx.Observable.concat(
                // downloadSpecificRuntime("omnisharp.bootstrap", ctx, logger, dest),
                _this3._downloadSpecificRuntime("omnisharp"));
            }).subscribeOn(_rx.Scheduler.async).toArray();
        }
    }, {
        key: "downloadRuntimeIfMissing",
        value: function downloadRuntimeIfMissing() {
            var _this4 = this;

            return this._ensureCurrentVersion().flatMap(function (isCurrent) {
                return _this4.findRuntime().isEmpty();
            }).flatMap(function (empty) {
                return _rx.Observable.if(function () {
                    return empty;
                }, _this4.downloadRuntime());
            });
        }
    }, {
        key: "_downloadSpecificRuntime",
        value: function _downloadSpecificRuntime(name) {
            var _this5 = this;

            var filename = name + "-" + this._key + "." + (this._platform === "win32" ? "zip" : "tar.gz");
            var destination = this._destination;
            try {
                if (!fs.existsSync(destination)) fs.mkdirSync(destination);
            } catch (e) {}
            var url = "https://github.com/OmniSharp/omnisharp-roslyn/releases/download/" + this._version + "/" + filename;
            var path = (0, _path.join)(destination, filename);
            return _rx.Observable.defer(function () {
                return _rx.Observable.concat(_this5.downloadFile(url, path).delay(100), _rx.Observable.defer(function () {
                    return _this5._extract(_this5._platform === "win32", path, destination);
                })).tapOnCompleted(function () {
                    try {
                        fs.unlinkSync(path);
                    } catch (e) {}
                }).subscribeOn(_rx.Scheduler.async);
            }).map(function () {
                return name;
            });
        }
    }, {
        key: "downloadFile",
        value: function downloadFile(url, path) {
            var _this6 = this;

            this._logger.log("Downloading " + path);
            return _rx.Observable.create(function (observer) {
                request.get(url).pipe(fs.createWriteStream(path)).on("error", (0, _lodash.bind)(observer.onError, observer)).on("finish", function () {
                    _this6._logger.log("Finished downloading " + path);
                    observer.onNext(null);
                    observer.onCompleted();
                });
            });
        }
    }, {
        key: "_extract",
        value: function _extract(win32, path, dest) {
            var _this7 = this;

            return _rx.Observable.create(function (observer) {
                _this7._logger.log("Extracting " + path);
                console.log(path, dest);
                new _decompress.Decompress({ mode: "755" }).src(path).dest(dest).run(function (err, files) {
                    if (err) {
                        observer.onError(err);
                        return;
                    }
                    _this7._logger.log("Finished extracting " + path);
                    observer.onCompleted();
                });
            });
        }
    }, {
        key: "runtime",
        get: function get() {
            return this._runtime;
        }
    }, {
        key: "platform",
        get: function get() {
            return this._platform;
        }
    }, {
        key: "arch",
        get: function get() {
            return this._arch;
        }
    }, {
        key: "bootstrap",
        get: function get() {
            return this._bootstrap;
        }
    }, {
        key: "version",
        get: function get() {
            return this._version;
        }
    }, {
        key: "destination",
        get: function get() {
            return this._destination;
        }
    }, {
        key: "id",
        get: function get() {
            return this._id;
        }
    }, {
        key: "location",
        get: function get() {
            return this._location;
        }
    }]);

    return RuntimeContext;
}();

var isSupportedRuntime = exports.isSupportedRuntime = (0, _lodash.memoize)(function (ctx) {
    return _rx.Observable.defer(function () {
        // On windows we'll just use the clr, it's there
        // On mac / linux if we've picked CoreClr stick with that
        if (ctx.platform === "win32" || ctx.runtime === _enums.Runtime.CoreClr) {
            return _rx.Observable.just({ runtime: ctx.runtime, path: process.env.PATH });
        }
        // We need to check if mono exists on the system
        // If it doesn't we'll just run CoreClr
        return _rx.Observable.from(PATH).map(function (path) {
            return (0, _path.join)(path, "mono");
        }).concatMap(function (path) {
            return exists(path).map(function (e) {
                return { exists: e, path: path };
            });
        }).where(function (x) {
            return x.exists;
        }).map(function (x) {
            return { runtime: _enums.Runtime.ClrOrMono, path: [x.path].concat(PATH).join(_path.delimiter) };
        }).take(1).defaultIfEmpty({ runtime: _enums.Runtime.CoreClr, path: process.env.PATH });
    }).do(function (ct) {
        return console.log("Supported runtime for \"" + _enums.Runtime[ct.runtime] + "\" was: " + _enums.Runtime[ct.runtime]);
    }).shareReplay(1);
}, function (_ref) {
    var platform = _ref.platform;
    var arch = _ref.arch;
    var runtime = _ref.runtime;
    var version = _ref.version;
    return arch + "-" + platform + ":" + _enums.Runtime[runtime] + ":" + version;
});
function findRuntimeById(runtimeId, location) {
    return _rx.Observable.merge(exists((0, _path.resolve)(location, runtimeId, "OmniSharp.exe")), exists((0, _path.resolve)(location, runtimeId, "OmniSharp"))).filter(function (x) {
        return x;
    }).take(1).map(function (x) {
        return (0, _path.resolve)(location, runtimeId);
    }).share();
}