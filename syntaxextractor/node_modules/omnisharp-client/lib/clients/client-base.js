"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClientEventsBase = exports.ClientBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _rx = require("rx");

var _lodash = require("lodash");

var _enums = require("../enums");

var _contexts = require("../contexts");

var _responseHandling = require("../response-handling");

var _options2 = require("../options");

var _decorators = require("../decorators");

var _prioritization = require("../helpers/prioritization");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};

//import {PluginManager} from "../helpers/plugin-manager";

var ClientBase = function () {
    function ClientBase(_options, observableFactory) {
        var _this = this;

        _classCallCheck(this, ClientBase);

        this._options = _options;
        this._requestStream = new _rx.Subject();
        this._responseStream = new _rx.Subject();
        this._errorStream = new _rx.Subject();
        this._customEvents = new _rx.Subject();
        this._uniqueId = (0, _lodash.uniqueId)("client");
        this._eventWatchers = new Map();
        this._commandWatchers = new Map();
        this._disposable = new _rx.CompositeDisposable();
        this._currentRequests = new Set();
        this._fixups = [];
        _options.driver = _options.driver || _enums.Driver.Stdio;
        (0, _options2.ensureClientOptions)(_options);
        //this._pluginManager = new PluginManager(_options.plugins);
        this._resetDriver();
        /*this._disposable.add(this._pluginManager.changed.subscribe(() => {
            const driver = this._driver;
            if (isPluginDriver(driver)) {
                driver.updatePlugins(this._pluginManager.plugins);
            }
        }));*/
        this._enqueuedEvents = _rx.Observable.merge(this._customEvents, this._driver.events).map(function (event) {
            if ((0, _lodash.isObject)(event.Body)) {
                Object.freeze(event.Body);
            }
            return Object.freeze(event);
        });
        this._enqueuedResponses = _rx.Observable.merge(this._responseStream, this._driver.commands.map(function (packet) {
            return new _contexts.ResponseContext(new _contexts.RequestContext(_this._uniqueId, packet.Command, {}, {}, "command"), packet.Body);
        }));
        this._lowestIndexValue = _options.oneBasedIndices ? 1 : 0;
        this._disposable.add(this._requestStream.subscribe(function (x) {
            return _this._currentRequests.add(x);
        }));
        var getStatusValues = function getStatusValues() {
            return {
                state: _this._driver.currentState,
                outgoingRequests: _this.outstandingRequests,
                hasOutgoingRequests: _this.outstandingRequests > 0
            };
        };
        this.setupRequestStreams();
        this.setupObservers();
        var status = _rx.Observable.merge(this._requestStream, this._responseStream);
        this._statusStream = status.delay(10).map(getStatusValues).distinctUntilChanged().map(Object.freeze).share();
        this._observe = observableFactory(this);
        if (this._options.debug) {
            this._disposable.add(this._responseStream.subscribe(function (context) {
                // log our complete response time
                _this._customEvents.onNext({
                    Event: "log",
                    Body: {
                        Message: "/" + context.command + "  " + context.responseTime + "ms (round trip)",
                        LogLevel: "INFORMATION"
                    },
                    Seq: -1,
                    Type: "log"
                });
            }));
        }
    }
    //private _pluginManager: PluginManager;


    _createClass(ClientBase, [{
        key: "getCurrentRequests",
        value: function getCurrentRequests() {
            var response = [];
            this._currentRequests.forEach(function (request) {
                response.push({
                    command: request.command,
                    sequence: (0, _lodash.cloneDeep)(request.sequence),
                    request: request.request,
                    silent: request.silent,
                    duration: Date.now() - request.time.getTime()
                });
            });
            return response;
        }
    }, {
        key: "dispose",
        value: function dispose() {
            if (this._disposable.isDisposed) return;
            this.disconnect();
            this._disposable.dispose();
        }
    }, {
        key: "setupRequestStreams",
        value: function setupRequestStreams() {
            var _this2 = this;

            var priorityRequests = new _rx.BehaviorSubject(0),
                priorityResponses = new _rx.BehaviorSubject(0);
            var pauser = _rx.Observable.combineLatest(priorityRequests, priorityResponses, function (requests, responses) {
                if (requests > 0 && responses === requests) {
                    priorityRequests.onNext(0);
                    priorityResponses.onNext(0);
                    return true;
                } else if (requests > 0) {
                    return false;
                }
                return true;
            }).startWith(true).debounce(120);
            // Keep deferred concurrency at a min of two, this lets us get around long running requests jamming the pipes.
            var deferredConcurrency = Math.max(Math.floor(this._options.concurrency / 4), 2);
            // These are operations that should wait until after
            // we have executed all the current priority commands
            // We also defer silent commands to this queue, as they are generally for "background" work
            var deferredQueue = this._requestStream.filter(_prioritization.isDeferredCommand).pausableBuffered(pauser).map(function (request) {
                return _this2.handleResult(request);
            }).merge(deferredConcurrency);
            // We just pass these operations through as soon as possible
            var normalQueue = this._requestStream.filter(_prioritization.isNormalCommand).pausableBuffered(pauser).map(function (request) {
                return _this2.handleResult(request);
            }).merge(this._options.concurrency);
            // We must wait for these commands
            // And these commands must run in order.
            var priorityQueue = this._requestStream.filter(_prioritization.isPriorityCommand).do(function () {
                return priorityRequests.onNext(priorityRequests.getValue() + 1);
            }).map(function (request) {
                return _this2.handleResult(request, function () {
                    return priorityResponses.onNext(priorityResponses.getValue() + 1);
                });
            }).merge(this._options.concurrency);
            this._disposable.add(_rx.Observable.merge(deferredQueue, normalQueue, priorityQueue).subscribe());
        }
    }, {
        key: "handleResult",
        value: function handleResult(context, onComplete) {
            var _this3 = this;

            // TODO: Find a way to not repeat the same commands, if there are outstanding (timed out) requests.
            // In some cases for example find usages has taken over 30 seconds, so we shouldn"t hit the server with multiple of these requests (as we slam the cpU)
            var result = this._driver.request(context.command, context.request);
            result.subscribe(function (data) {
                _this3._responseStream.onNext(new _contexts.ResponseContext(context, data));
            }, function (error) {
                _this3._errorStream.onNext(new _contexts.CommandContext(context.command, error));
                _this3._responseStream.onNext(new _contexts.ResponseContext(context, null, true));
                _this3._currentRequests.delete(context);
                if (onComplete) {
                    onComplete();
                    onComplete = null;
                }
            }, function () {
                _this3._currentRequests.delete(context);
                if (onComplete) {
                    onComplete();
                    onComplete = null;
                }
            });
            return result.timeout(this._options.concurrencyTimeout, _rx.Observable.empty());
        }
    }, {
        key: "log",
        value: function log(message, logLevel) {
            // log our complete response time
            this._customEvents.onNext({
                Event: "log",
                Body: {
                    Message: message,
                    LogLevel: logLevel ? logLevel.toUpperCase() : "INFORMATION"
                },
                Seq: -1,
                Type: "log"
            });
        }
    }, {
        key: "connect",
        value: function connect() {
            // Currently connecting
            if (this.currentState >= _enums.DriverState.Downloading && this.currentState <= _enums.DriverState.Connected) return;
            // Bootstrap plugins here
            this._currentRequests.clear();
            this._driver.connect();
        }
    }, {
        key: "_resetDriver",
        value: function _resetDriver() {
            if (this._driver) {
                this._disposable.remove(this._driver);
                this._driver.dispose();
            }
            var driver = this._options.driver;

            var item = require("../drivers/" + _enums.Driver[driver].toLowerCase());
            var driverFactory = item[(0, _lodash.keys)(item)[0]];
            this._driver = new driverFactory(this._options);
            this._disposable.add(this._driver);
            return this._driver;
        }
    }, {
        key: "disconnect",
        value: function disconnect() {
            this._driver.disconnect();
        }
    }, {
        key: "request",
        value: function request(action, _request, options) {
            var _this4 = this;

            if (!options) options = {};
            (0, _lodash.defaults)(options, { oneBasedIndices: this._options.oneBasedIndices });
            // Handle disconnected requests
            if (this.currentState !== _enums.DriverState.Connected && this.currentState !== _enums.DriverState.Error) {
                var _ret = function () {
                    var response = new _rx.AsyncSubject();
                    _this4.state.where(function (z) {
                        return z === _enums.DriverState.Connected;
                    }).take(1).subscribe(function (z) {
                        _this4.request(action, _request, options).subscribe(function (x) {
                            return response.onNext(x);
                        });
                    });
                    return {
                        v: response
                    };
                }();

                if ((typeof _ret === "undefined" ? "undefined" : _typeof(_ret)) === "object") return _ret.v;
            }
            var context = new _contexts.RequestContext(this._uniqueId, action, _request, options);
            this._requestStream.onNext(context);
            return context.getResponse(this._responseStream);
        }
    }, {
        key: "setupObservers",
        value: function setupObservers() {
            var _this5 = this;

            this._driver.events.subscribe(function (x) {
                if (_this5._eventWatchers.has(x.Event)) _this5._eventWatchers.get(x.Event)[0].onNext(x.Body);
            });
            this._enqueuedResponses.subscribe(function (x) {
                if (!x.silent && _this5._commandWatchers.has(x.command)) _this5._commandWatchers.get(x.command)[0].onNext(x);
            });
        }
    }, {
        key: "registerFixup",
        value: function registerFixup(func) {
            this._fixups.push(func);
        }
        /* tslint:disable:no-unused-variable */

    }, {
        key: "_fixup",
        value: function _fixup(action, request, options) {
            (0, _lodash.each)(this._fixups, function (f) {
                return f(action, request, options);
            });
        }
    }, {
        key: "uniqueId",
        get: function get() {
            return this._uniqueId;
        }
    }, {
        key: "id",
        get: function get() {
            return this._driver.id;
        }
    }, {
        key: "serverPath",
        get: function get() {
            return this._driver.serverPath;
        }
    }, {
        key: "projectPath",
        get: function get() {
            return this._driver.projectPath;
        }
    }, {
        key: "runtime",
        get: function get() {
            return this._driver.runtime;
        }
    }, {
        key: "currentState",
        get: function get() {
            return this._driver.currentState;
        }
    }, {
        key: "events",
        get: function get() {
            return this._enqueuedEvents;
        }
    }, {
        key: "commands",
        get: function get() {
            return this._driver.commands;
        }
    }, {
        key: "state",
        get: function get() {
            return this._driver.state;
        }
    }, {
        key: "outstandingRequests",
        get: function get() {
            return this._currentRequests.size;
        }
    }, {
        key: "status",
        get: function get() {
            return this._statusStream;
        }
    }, {
        key: "requests",
        get: function get() {
            return this._requestStream;
        }
    }, {
        key: "responses",
        get: function get() {
            return this._enqueuedResponses;
        }
    }, {
        key: "errors",
        get: function get() {
            return this._errorStream;
        }
    }, {
        key: "observe",
        get: function get() {
            return this._observe;
        }
    }]);

    return ClientBase;
}();

exports.ClientBase = ClientBase;

ClientBase.serverLineNumbers = _responseHandling.serverLineNumbers;
ClientBase.serverLineNumberArrays = _responseHandling.serverLineNumberArrays;

var ClientEventsBase = exports.ClientEventsBase = function () {
    function ClientEventsBase(_client) {
        _classCallCheck(this, ClientEventsBase);

        this._client = _client;
    }

    _createClass(ClientEventsBase, [{
        key: "uniqueId",
        get: function get() {
            return this._client.uniqueId;
        }
    }, {
        key: "projectAdded",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "projectChanged",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "projectRemoved",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "error",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "msBuildProjectDiagnostics",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "packageRestoreStarted",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "packageRestoreFinished",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "unresolvedDependencies",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "events",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "commands",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "state",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "status",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "requests",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "responses",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }, {
        key: "errors",
        get: function get() {
            throw new Error("Implemented by decorator");
        }
    }]);

    return ClientEventsBase;
}();

__decorate([_decorators.watchEvent], ClientEventsBase.prototype, "projectAdded", null);
__decorate([_decorators.watchEvent], ClientEventsBase.prototype, "projectChanged", null);
__decorate([_decorators.watchEvent], ClientEventsBase.prototype, "projectRemoved", null);
__decorate([_decorators.watchEvent], ClientEventsBase.prototype, "error", null);
__decorate([_decorators.watchEvent], ClientEventsBase.prototype, "msBuildProjectDiagnostics", null);
__decorate([_decorators.watchEvent], ClientEventsBase.prototype, "packageRestoreStarted", null);
__decorate([_decorators.watchEvent], ClientEventsBase.prototype, "packageRestoreFinished", null);
__decorate([_decorators.watchEvent], ClientEventsBase.prototype, "unresolvedDependencies", null);
__decorate([_decorators.reference], ClientEventsBase.prototype, "events", null);
__decorate([_decorators.reference], ClientEventsBase.prototype, "commands", null);
__decorate([_decorators.reference], ClientEventsBase.prototype, "state", null);
__decorate([_decorators.reference], ClientEventsBase.prototype, "status", null);
__decorate([_decorators.reference], ClientEventsBase.prototype, "requests", null);
__decorate([_decorators.reference], ClientEventsBase.prototype, "responses", null);
__decorate([_decorators.reference], ClientEventsBase.prototype, "errors", null);