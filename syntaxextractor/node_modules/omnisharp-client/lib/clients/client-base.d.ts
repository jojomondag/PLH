import * as OmniSharp from "../omnisharp-server";
import { IDriver, OmnisharpClientStatus, OmnisharpClientOptions } from "../enums";
import { DriverState } from "../enums";
import { RequestContext, ResponseContext, CommandContext } from "../contexts";
export declare class ClientBase<TEvents extends ClientEventsBase> implements IDriver, Rx.IDisposable {
    private _options;
    static serverLineNumbers: string[];
    static serverLineNumberArrays: string[];
    private _driver;
    private _requestStream;
    private _responseStream;
    private _statusStream;
    private _errorStream;
    private _customEvents;
    private _uniqueId;
    protected _lowestIndexValue: number;
    private _eventWatchers;
    private _commandWatchers;
    private _disposable;
    private _plugins;
    uniqueId: string;
    id: string;
    serverPath: string;
    projectPath: string;
    currentState: DriverState;
    private _enqueuedEvents;
    events: Rx.Observable<OmniSharp.Stdio.Protocol.EventPacket>;
    commands: Rx.Observable<OmniSharp.Stdio.Protocol.ResponsePacket>;
    state: Rx.Observable<DriverState>;
    outstandingRequests: number;
    private _currentRequests;
    getCurrentRequests(): {
        command: string;
        sequence: string;
        silent: boolean;
        request: any;
        duration: number;
    }[];
    status: Rx.Observable<OmnisharpClientStatus>;
    requests: Rx.Observable<RequestContext<any>>;
    private _enqueuedResponses;
    responses: Rx.Observable<ResponseContext<any, any>>;
    errors: Rx.Observable<CommandContext<any>>;
    private _observe;
    observe: TEvents;
    constructor(_options: OmnisharpClientOptions, observableFactory: (client: ClientBase<TEvents>) => TEvents);
    dispose(): void;
    private setupRequestStreams();
    private handleResult(context, onComplete?);
    log(message: string, logLevel?: string): void;
    connect(): void;
    disconnect(): void;
    request<TRequest, TResponse>(action: string, request: TRequest, options?: OmniSharp.RequestOptions): Rx.Observable<TResponse>;
    private setupObservers();
    private _fixups;
    registerFixup(func: (action: string, request: any, options?: OmniSharp.RequestOptions) => void): void;
    private _fixup<TRequest>(action, request, options?);
}
export declare class ClientEventsBase implements OmniSharp.Events {
    private _client;
    constructor(_client: any);
    uniqueId: any;
    projectAdded: Rx.Observable<OmniSharp.Models.ProjectInformationResponse>;
    projectChanged: Rx.Observable<OmniSharp.Models.ProjectInformationResponse>;
    projectRemoved: Rx.Observable<OmniSharp.Models.ProjectInformationResponse>;
    error: Rx.Observable<OmniSharp.Models.ErrorMessage>;
    msBuildProjectDiagnostics: Rx.Observable<OmniSharp.Models.MSBuildProjectDiagnostics>;
    packageRestoreStarted: Rx.Observable<OmniSharp.Models.PackageRestoreMessage>;
    packageRestoreFinished: Rx.Observable<OmniSharp.Models.PackageRestoreMessage>;
    unresolvedDependencies: Rx.Observable<OmniSharp.Models.UnresolvedDependenciesMessage>;
    events: Rx.Observable<OmniSharp.Stdio.Protocol.EventPacket>;
    commands: Rx.Observable<OmniSharp.Stdio.Protocol.ResponsePacket>;
    state: Rx.Observable<DriverState>;
    status: Rx.Observable<OmnisharpClientStatus>;
    requests: Rx.Observable<RequestContext<any>>;
    responses: Rx.Observable<ResponseContext<any, any>>;
    errors: Rx.Observable<CommandContext<any>>;
}
