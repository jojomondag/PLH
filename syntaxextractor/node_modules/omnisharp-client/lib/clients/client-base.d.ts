import * as OmniSharp from "../omnisharp-server";
import { IDriver, OmnisharpClientStatus, OmnisharpClientOptions } from "../enums";
import { DriverState, Runtime } from "../enums";
import { RequestContext, ResponseContext, CommandContext } from "../contexts";
export declare class ClientBase<TEvents extends ClientEventsBase> implements IDriver, Rx.IDisposable {
    private _options;
    static serverLineNumbers: string[];
    static serverLineNumberArrays: string[];
    private _driver;
    private _requestStream;
    private _responseStream;
    private _statusStream;
    private _errorStream;
    private _customEvents;
    private _uniqueId;
    protected _lowestIndexValue: number;
    private _eventWatchers;
    private _commandWatchers;
    private _disposable;
    readonly uniqueId: string;
    readonly id: string;
    readonly serverPath: string;
    readonly projectPath: string;
    readonly runtime: Runtime;
    readonly currentState: DriverState;
    private _enqueuedEvents;
    readonly events: Rx.Observable<OmniSharp.Stdio.Protocol.EventPacket>;
    readonly commands: Rx.Observable<OmniSharp.Stdio.Protocol.ResponsePacket>;
    readonly state: Rx.Observable<DriverState>;
    readonly outstandingRequests: number;
    private _currentRequests;
    getCurrentRequests(): {
        command: string;
        sequence: string;
        silent: boolean;
        request: any;
        duration: number;
    }[];
    readonly status: Rx.Observable<OmnisharpClientStatus>;
    readonly requests: Rx.Observable<RequestContext<any>>;
    private _enqueuedResponses;
    readonly responses: Rx.Observable<ResponseContext<any, any>>;
    readonly errors: Rx.Observable<CommandContext<any>>;
    private _observe;
    readonly observe: TEvents;
    constructor(_options: OmnisharpClientOptions, observableFactory: (client: ClientBase<TEvents>) => TEvents);
    dispose(): void;
    private setupRequestStreams();
    private handleResult(context, onComplete?);
    log(message: string, logLevel?: string): void;
    connect(): void;
    private _resetDriver();
    disconnect(): void;
    request<TRequest, TResponse>(action: string, request: TRequest, options?: OmniSharp.RequestOptions): Rx.Observable<TResponse>;
    private setupObservers();
    private _fixups;
    registerFixup(func: (action: string, request: any, options?: OmniSharp.RequestOptions) => void): void;
    private _fixup<TRequest>(action, request, options?);
}
export declare class ClientEventsBase implements OmniSharp.Events {
    private _client;
    constructor(_client: any);
    readonly uniqueId: any;
    readonly projectAdded: Rx.Observable<OmniSharp.Models.ProjectInformationResponse>;
    readonly projectChanged: Rx.Observable<OmniSharp.Models.ProjectInformationResponse>;
    readonly projectRemoved: Rx.Observable<OmniSharp.Models.ProjectInformationResponse>;
    readonly error: Rx.Observable<OmniSharp.Models.ErrorMessage>;
    readonly msBuildProjectDiagnostics: Rx.Observable<OmniSharp.Models.MSBuildProjectDiagnostics>;
    readonly packageRestoreStarted: Rx.Observable<OmniSharp.Models.PackageRestoreMessage>;
    readonly packageRestoreFinished: Rx.Observable<OmniSharp.Models.PackageRestoreMessage>;
    readonly unresolvedDependencies: Rx.Observable<OmniSharp.Models.UnresolvedDependenciesMessage>;
    readonly events: Rx.Observable<OmniSharp.Stdio.Protocol.EventPacket>;
    readonly commands: Rx.Observable<OmniSharp.Stdio.Protocol.ResponsePacket>;
    readonly state: Rx.Observable<DriverState>;
    readonly status: Rx.Observable<OmnisharpClientStatus>;
    readonly requests: Rx.Observable<RequestContext<any>>;
    readonly responses: Rx.Observable<ResponseContext<any, any>>;
    readonly errors: Rx.Observable<CommandContext<any>>;
}
